\hypertarget{gc_8h}{}\section{gc.\+h File Reference}
\label{gc_8h}\index{gc.\+h@{gc.\+h}}
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdbool.\+h$>$}\\*
{\ttfamily \#include $<$stdint.\+h$>$}\\*
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structheap__s}{heap\+\_\+s} $\ast$ \hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap}
\item 
typedef void $\ast$($\ast$ \hyperlink{gc_8h_a06b2359261c4a4b38a68770cac5af7bb}{trace\+\_\+f}) (\hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap} h, void $\ast$obj)
\item 
typedef void $\ast$($\ast$ \hyperlink{gc_8h_aa76b6071b446d0df3c9902129945e6f0}{s\+\_\+trace\+\_\+f}) (\hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap} h, \hyperlink{header_8h_a06b2359261c4a4b38a68770cac5af7bb}{trace\+\_\+f} f, void $\ast$obj)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap} \hyperlink{gc_8h_a2123e3185101ad86e7ed5dbe7210bf25}{h\+\_\+init} (size\+\_\+t bytes)
\item 
void \hyperlink{gc_8h_a8bfdaf00e60803da44395ed077bfd645}{h\+\_\+delete} (\hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap} h)
\item 
void \hyperlink{gc_8h_afc91144f01355b8a6f9632d2f81f29b4}{h\+\_\+delete\+\_\+dbg} (\hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap} h, void $\ast$dbg\+\_\+value)
\item 
void $\ast$ \hyperlink{gc_8h_a36318eaff8f837a41a910190dbbd76dc}{h\+\_\+alloc\+\_\+struct} (\hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap} h, char $\ast$layout)
\item 
void $\ast$ \hyperlink{gc_8h_aa5b9c5854d38c3a0e9e48295dbfbfa26}{h\+\_\+alloc\+\_\+union} (\hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap} h, size\+\_\+t bytes, \hyperlink{header_8h_aa76b6071b446d0df3c9902129945e6f0}{s\+\_\+trace\+\_\+f} f)
\item 
void $\ast$ \hyperlink{gc_8h_a2a728040d82ffc65888b5f7f4ee3654a}{h\+\_\+alloc\+\_\+data} (\hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap} h, size\+\_\+t bytes)
\item 
size\+\_\+t \hyperlink{gc_8h_ace6a24ee98a92576ed23bb6db1d9ca6f}{h\+\_\+gc} (\hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap} h)
\item 
size\+\_\+t \hyperlink{gc_8h_a24d98172862af9f802328e712088e65e}{h\+\_\+avail} (\hyperlink{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{Heap} h)
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\hypertarget{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}{}\index{gc.\+h@{gc.\+h}!Heap@{Heap}}
\index{Heap@{Heap}!gc.\+h@{gc.\+h}}
\subsubsection[{Heap}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf heap\+\_\+s}$\ast$ {\bf Heap}}\label{gc_8h_acff7c46ae1f4265ad565cc6ccf18dacb}
The opaque data type holding all the heap data \hypertarget{gc_8h_aa76b6071b446d0df3c9902129945e6f0}{}\index{gc.\+h@{gc.\+h}!s\+\_\+trace\+\_\+f@{s\+\_\+trace\+\_\+f}}
\index{s\+\_\+trace\+\_\+f@{s\+\_\+trace\+\_\+f}!gc.\+h@{gc.\+h}}
\subsubsection[{s\+\_\+trace\+\_\+f}]{\setlength{\rightskip}{0pt plus 5cm}typedef void$\ast$($\ast$ s\+\_\+trace\+\_\+f) ({\bf Heap} h, {\bf trace\+\_\+f} f, void $\ast$obj)}\label{gc_8h_aa76b6071b446d0df3c9902129945e6f0}
The signature of object-\/specific trace functions. It will be called for its specific objects, and be given a generic trace function f to be called on each pointer inside obj. \hypertarget{gc_8h_a06b2359261c4a4b38a68770cac5af7bb}{}\index{gc.\+h@{gc.\+h}!trace\+\_\+f@{trace\+\_\+f}}
\index{trace\+\_\+f@{trace\+\_\+f}!gc.\+h@{gc.\+h}}
\subsubsection[{trace\+\_\+f}]{\setlength{\rightskip}{0pt plus 5cm}typedef void$\ast$($\ast$ trace\+\_\+f) ({\bf Heap} h, void $\ast$obj)}\label{gc_8h_a06b2359261c4a4b38a68770cac5af7bb}
The signature of the trace function 

\subsection{Function Documentation}
\hypertarget{gc_8h_a2a728040d82ffc65888b5f7f4ee3654a}{}\index{gc.\+h@{gc.\+h}!h\+\_\+alloc\+\_\+data@{h\+\_\+alloc\+\_\+data}}
\index{h\+\_\+alloc\+\_\+data@{h\+\_\+alloc\+\_\+data}!gc.\+h@{gc.\+h}}
\subsubsection[{h\+\_\+alloc\+\_\+data}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ h\+\_\+alloc\+\_\+data (
\begin{DoxyParamCaption}
\item[{{\bf Heap}}]{h, }
\item[{size\+\_\+t}]{bytes}
\end{DoxyParamCaption}
)}\label{gc_8h_a2a728040d82ffc65888b5f7f4ee3654a}
Allocate a new object on a heap with a given size. Objects allocated with this function will {\itshape not} be further traced for pointers. 
\begin{DoxyParams}{Parameters}
{\em h} & the heap \\
\hline
{\em bytes} & the size in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly allocated object 
\end{DoxyReturn}
\hypertarget{gc_8h_a36318eaff8f837a41a910190dbbd76dc}{}\index{gc.\+h@{gc.\+h}!h\+\_\+alloc\+\_\+struct@{h\+\_\+alloc\+\_\+struct}}
\index{h\+\_\+alloc\+\_\+struct@{h\+\_\+alloc\+\_\+struct}!gc.\+h@{gc.\+h}}
\subsubsection[{h\+\_\+alloc\+\_\+struct}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ h\+\_\+alloc\+\_\+struct (
\begin{DoxyParamCaption}
\item[{{\bf Heap}}]{h, }
\item[{char $\ast$}]{layout}
\end{DoxyParamCaption}
)}\label{gc_8h_a36318eaff8f837a41a910190dbbd76dc}
Allocate a new object on a heap with a given format string. Valid characters in format strings are\+:
\begin{DoxyItemize}
\item 'd' -- for sizeof(int) bytes 'raw' data
\item '$\ast$' -- for a sizeof(void $\ast$) bytes pointer value
\item '\textbackslash{}0' -- null-\/character terminates the format string 
\begin{DoxyParams}{Parameters}
{\em h} & the heap \\
\hline
{\em layout} & the format string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly allocated object Note\+: the heap does {\itshape not} retain an alias to layout. 
\end{DoxyReturn}

\end{DoxyItemize}\hypertarget{gc_8h_aa5b9c5854d38c3a0e9e48295dbfbfa26}{}\index{gc.\+h@{gc.\+h}!h\+\_\+alloc\+\_\+union@{h\+\_\+alloc\+\_\+union}}
\index{h\+\_\+alloc\+\_\+union@{h\+\_\+alloc\+\_\+union}!gc.\+h@{gc.\+h}}
\subsubsection[{h\+\_\+alloc\+\_\+union}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ h\+\_\+alloc\+\_\+union (
\begin{DoxyParamCaption}
\item[{{\bf Heap}}]{h, }
\item[{size\+\_\+t}]{bytes, }
\item[{{\bf s\+\_\+trace\+\_\+f}}]{f}
\end{DoxyParamCaption}
)}\label{gc_8h_aa5b9c5854d38c3a0e9e48295dbfbfa26}
Allocate a new object on a heap with a given size, and object-\/specific trace function. 
\begin{DoxyParams}{Parameters}
{\em h} & the heap \\
\hline
{\em bytes} & the size in bytes \\
\hline
{\em f} & the object-\/specific trace function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the newly allocated object 
\end{DoxyReturn}
\hypertarget{gc_8h_a24d98172862af9f802328e712088e65e}{}\index{gc.\+h@{gc.\+h}!h\+\_\+avail@{h\+\_\+avail}}
\index{h\+\_\+avail@{h\+\_\+avail}!gc.\+h@{gc.\+h}}
\subsubsection[{h\+\_\+avail}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t h\+\_\+avail (
\begin{DoxyParamCaption}
\item[{{\bf Heap}}]{h}
\end{DoxyParamCaption}
)}\label{gc_8h_a24d98172862af9f802328e712088e65e}
Returns the available consecutive free memory. 
\begin{DoxyParams}{Parameters}
{\em h} & the heap \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the available consecutive free memory. 
\end{DoxyReturn}
\hypertarget{gc_8h_a8bfdaf00e60803da44395ed077bfd645}{}\index{gc.\+h@{gc.\+h}!h\+\_\+delete@{h\+\_\+delete}}
\index{h\+\_\+delete@{h\+\_\+delete}!gc.\+h@{gc.\+h}}
\subsubsection[{h\+\_\+delete}]{\setlength{\rightskip}{0pt plus 5cm}void h\+\_\+delete (
\begin{DoxyParamCaption}
\item[{{\bf Heap}}]{h}
\end{DoxyParamCaption}
)}\label{gc_8h_a8bfdaf00e60803da44395ed077bfd645}
Delete a heap. 
\begin{DoxyParams}{Parameters}
{\em h} & the heap \\
\hline
\end{DoxyParams}
\hypertarget{gc_8h_afc91144f01355b8a6f9632d2f81f29b4}{}\index{gc.\+h@{gc.\+h}!h\+\_\+delete\+\_\+dbg@{h\+\_\+delete\+\_\+dbg}}
\index{h\+\_\+delete\+\_\+dbg@{h\+\_\+delete\+\_\+dbg}!gc.\+h@{gc.\+h}}
\subsubsection[{h\+\_\+delete\+\_\+dbg}]{\setlength{\rightskip}{0pt plus 5cm}void h\+\_\+delete\+\_\+dbg (
\begin{DoxyParamCaption}
\item[{{\bf Heap}}]{h, }
\item[{void $\ast$}]{dbg\+\_\+value}
\end{DoxyParamCaption}
)}\label{gc_8h_afc91144f01355b8a6f9632d2f81f29b4}
Delete a heap and trace, killing off stack pointers. 
\begin{DoxyParams}{Parameters}
{\em h} & the heap \\
\hline
{\em dbg\+\_\+value} & a value to be written into every pointer into h on the stack \\
\hline
\end{DoxyParams}
\hypertarget{gc_8h_ace6a24ee98a92576ed23bb6db1d9ca6f}{}\index{gc.\+h@{gc.\+h}!h\+\_\+gc@{h\+\_\+gc}}
\index{h\+\_\+gc@{h\+\_\+gc}!gc.\+h@{gc.\+h}}
\subsubsection[{h\+\_\+gc}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t h\+\_\+gc (
\begin{DoxyParamCaption}
\item[{{\bf Heap}}]{h}
\end{DoxyParamCaption}
)}\label{gc_8h_ace6a24ee98a92576ed23bb6db1d9ca6f}
Manually trigger garbage collection. Garbage collection is otherwise run when an allocation is impossible in the available consecutive free memory. 
\begin{DoxyParams}{Parameters}
{\em h} & the heap \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes collected 
\end{DoxyReturn}
\hypertarget{gc_8h_a2123e3185101ad86e7ed5dbe7210bf25}{}\index{gc.\+h@{gc.\+h}!h\+\_\+init@{h\+\_\+init}}
\index{h\+\_\+init@{h\+\_\+init}!gc.\+h@{gc.\+h}}
\subsubsection[{h\+\_\+init}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Heap} h\+\_\+init (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{bytes}
\end{DoxyParamCaption}
)}\label{gc_8h_a2123e3185101ad86e7ed5dbe7210bf25}
Create a new heap with bytes total size (including both spaces and metadata), meaning strictly less than bytes will be available for allocation. 
\begin{DoxyParams}{Parameters}
{\em bytes} & the total size of the heap in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new heap 
\end{DoxyReturn}
